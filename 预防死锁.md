####预防死锁
#####锁排序
当多个线程获取同一个锁但是以不同的顺序，就会发生死锁。

如果你确保所有的锁一直以相同的顺序被其他线程获取，死锁就不会发生。看下面这例子：

    Thread 1:

	  lock A 
	  lock B
	
	
	Thread 2:
	
	   wait for A
	   lock C (when A locked)
	
	
	Thread 3:
	
	   wait for A
	   wait for B
	   wait for C

如果一个线程，像线程3，需要几个锁，就必须规定其获得锁的顺序。在它获得序列中靠前的锁之前不能够获得靠后的锁。

比如，线程2或者线程2首先要获得锁A，才能够获得锁C。因为，线程A持有锁A，线程2或者线程3首先必须等待直到锁A被释放。然后，在它们能够获得锁B或者C之前，必须成功获得锁A。

锁排序是一个简单但很有效的预防死锁的机制。但是，它仅适用于你事先知道所有的锁的情况下。它并不适用于所有的场景。

#####锁超时
 
 另一个预防死锁的机制是在请求锁时设置超时时长，也就说一个线程在设置的超时时长内如果没有获得锁就会放弃。如果一个线程在给定时长内没有成功获取所有必要的锁，它将会回退，释放所有的锁请求，随机等待一段时间，然后重试。随机等待的过程中给了其他线程获取这个锁的一个机会，因此，这也可以让程序在没有锁的情况下继续运行。

    Thread 1 locks A
	Thread 2 locks B
	
	Thread 1 attempts to lock B but is blocked
	Thread 2 attempts to lock A but is blocked
	
	Thread 1's lock attempt on B times out
	Thread 1 backs up and releases A as well
	Thread 1 waits randomly (e.g. 257 millis) before retrying.
	
	Thread 2's lock attempt on A times out
	Thread 2 backs up and releases B as well
	Thread 2 waits randomly (e.g. 43 millis) before retrying.

在上面的例子中，线程2将会在线程之前大约200毫秒重试去获得锁，所以，大体上将会获得所有的锁。已经在等待的线程A一直在尝试获取锁A。当线程2完成时，线程1也将会获得所有的锁。

我们需要记住一个问题，上面提到的仅仅是因为一个锁超时了，而不是说线程发生；了死锁，这也仅仅是说这个线程获取这个锁花费了多少时间去完成任务。

另外，如果线程足够多，尽管设置了超时和重试，也是会有发生死锁的风险。2个线程各自在重试前等待0~500毫秒也许不会发生死锁，但如果10或者20个线程情况就不同了。这种情况发生死锁的概率要比两个线程的情况要高得多。

锁超时机制存在的一个问题是在Java中在进入一个同步代码块时设置时长是不可能的。你不得不创建一个自定义的锁相关的类或者使用在Java5中<code>java.util.concurrency</code>包中的并发结构之一。

#####死锁检测

死锁检测是一个重量级的死锁预防机制，主要用于在锁排序和锁超时都不可用的场景中。

当一个线程请求一个锁当时请求被禁止时，这个线程可以遍历锁图（lock graph）检查是否发生了死锁。例如，如果一个线程A请求锁7，但是锁7被线程B持有，然后，线程A可以检测线程B是否有请求任何线程A持有的锁。如果有，就会发生一个死锁。

当然，一个死锁场景可能比两个对象分别持有对方的锁要复杂的锁。线程A可能等待线程B，线程B等待线程C，线程C等待线程D，线程D等待线程A。为了检测死锁，线程A必须一次测试所有的被线程B请求的锁。从线程B的锁请求线程A到达线程C，然后又到达线程D，从上面的检测中，线程A找到线程A自身持有的一个锁。这样，线程A就会知道发生了死锁。

下面是一个被四个线程持有和请求锁的图。类似于这样的一个数据结构可以用来检测死锁。

![detect_deadlocks](http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png)

那么，如果检测到一个死锁，这些线程可以做些什么？

一个可能的做法就是释放所有的锁，回退，随机等待一段时间然后重试。这种做法与锁超时机制非常相似除了只有发生死锁时线程才会回退（backup）。而不仅仅是因为锁请求超时。然而，如果大量的线程去请求同一个锁，可能重复的发生死锁，尽管存在回退和等待机制。

一个更好的做法就是为这些线程设置优先级，这样一来，就会只有一个或者一些线程在遇到死锁时发生回退。剩下的线程继续请求锁假如没有死锁再发生。如果赋予线程的优先级是固定的，同样的线程总是拥有更高的优先级。为了避免这种情况，我们可以在发生死锁时，随机的为线程设置优先级。